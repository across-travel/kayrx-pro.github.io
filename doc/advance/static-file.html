<h1 id="%e5%8d%95%e4%b8%aa%e6%96%87%e4%bb%b6">单个文件</h1>
<p>可以使用自定义路径模式和<code>NamedFile</code>来提供静态文件。为了匹配路径尾部，我们可以使用<code>\[.*]</code>正则表达式</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> keclc_files::NamedFile;
<span class="hljs-keyword">use</span> kayrx::web::{HttpRequest, <span class="hljs-built_in">Result</span>};
<span class="hljs-keyword">use</span> std::path::PathBuf;

async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(req: HttpRequest) -&gt; <span class="hljs-built_in">Result</span>&lt;NamedFile&gt; {
    <span class="hljs-keyword">let</span> path: PathBuf = req.match_info().query(<span class="hljs-string">"filename"</span>).parse().unwrap();
    <span class="hljs-literal">Ok</span>(NamedFile::open(path)?)
}

<span class="hljs-meta">#\[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; std::io::<span class="hljs-built_in">Result</span>&lt;()&gt; {
    <span class="hljs-keyword">use</span> kayrx::web::{web, App, HttpServer};

    HttpServer::new(|| App::new().route(<span class="hljs-string">"/{filename:.*}"</span>, web::get().to(index)))
        .bind(<span class="hljs-string">"127.0.0.1:8088"</span>)?
        .run()
        .await
}
</div></code></pre>
<h2 id="%e7%9b%ae%e5%bd%95">目录</h2>
<p><code>Files</code>可以支持来自特定目录和子目录的文件,  <code>Files</code>必须使用<code>App::service()</code>方法注册，否则它将无法支持子路径</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> keclc_files <span class="hljs-keyword">as</span> fs;
<span class="hljs-keyword">use</span> kayrx::web::{App, HttpServer};

<span class="hljs-meta">#\[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; std::io::<span class="hljs-built_in">Result</span>&lt;()&gt; {
    HttpServer::new(|| {
        App::new().service(fs::Files::new(<span class="hljs-string">"/static"</span>, <span class="hljs-string">"."</span>).show_files_listing())
    })
    .bind(<span class="hljs-string">"127.0.0.1:8088"</span>)?
    .run()
    .await
}
</div></code></pre>
<p>默认情况下，禁用子目录的文件列表。尝试加载目录列表将返回<code>404 Not Found</code>响应。要启用文件列表，请使用 <code>Files :: show_files_listing()</code> 方法.</p>
<p>除了显示目录的文件列表外，还可以重定向到特定的索引文件。使用<code>Files :: index_file()</code>方法配置此重定向.</p>
<h2 id="%e9%85%8d%e7%bd%ae">配置</h2>
<p><code>NamedFiles</code> 可以指定用于提供文件的各种选项：</p>
<ul>
<li><code>set_content_dispostion</code> - 用于将文件的<code>mime</code>映射到相应<code>Content-Disposition</code>类型的函数</li>
<li><code>use_etag</code> - 指定是否<code>ETag</code>应计算并包含在标头中</li>
<li><code>use_last_modifier</code> - 指定是否应使用文件修改的时间戳并将其添加到<code>Last-Modified</code>标头</li>
</ul>
<p>以上所有方法都是可选的，并提供了最佳默认值，但是可以自定义其中任何一种.</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> keclc_files <span class="hljs-keyword">as</span> fs;
<span class="hljs-keyword">use</span> kayrx::http::header::{ContentDisposition, DispositionType};
<span class="hljs-keyword">use</span> kayrx::web::{web, App, Error, HttpRequest, HttpServer};

async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(req: HttpRequest) -&gt; <span class="hljs-built_in">Result</span>&lt;fs::NamedFile, Error&gt; {
    <span class="hljs-keyword">let</span> path: std::path::PathBuf = req.match_info().query(<span class="hljs-string">"filename"</span>).parse().unwrap();
    <span class="hljs-keyword">let</span> file = fs::NamedFile::open(path)?;
    <span class="hljs-literal">Ok</span>(file
        .use_last_modified(<span class="hljs-literal">true</span>)
        .set_content_disposition(ContentDisposition {
            disposition: DispositionType::Attachment,
            parameters: <span class="hljs-built_in">vec!</span>\[],
        }))
}

<span class="hljs-meta">#\[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; std::io::<span class="hljs-built_in">Result</span>&lt;()&gt; {
    HttpServer::new(|| App::new().route(<span class="hljs-string">"/{filename:.*}"</span>, web::get().to(index)))
        .bind(<span class="hljs-string">"127.0.0.1:8088"</span>)?
        .run()
        .await
}
</div></code></pre>
<p>该配置也可以应用于目录服务：</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> keclc_files <span class="hljs-keyword">as</span> fs;
<span class="hljs-keyword">use</span> kayrx::web::{App, HttpServer};

<span class="hljs-meta">#\[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; std::io::<span class="hljs-built_in">Result</span>&lt;()&gt; {
    HttpServer::new(|| {
        App::new().service(
            fs::Files::new(<span class="hljs-string">"/static"</span>, <span class="hljs-string">"."</span>)
                .show_files_listing()
                .use_last_modified(<span class="hljs-literal">true</span>),
        )
    })
    .bind(<span class="hljs-string">"127.0.0.1:8088"</span>)?
    .run()
    .await
}
</div></code></pre>


[set title Kayrx / static-file]
[set doc-section advance-static-file]
[stash doc-content][require raw ../_side.html]