<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="https://avatars0.githubusercontent.com/u/58360786?s=200&v=4" title="Kayrx">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
    <link rel="stylesheet" type="text/css" href="/index.css" />
    <title>Kayrx / doc / server</title>
  </head>
  <body class="vscode-light">
    <div id="page" class="page-section-doc">
      <div id="mnav">
    
        <div id="lnav">
          <div id="left">
            <a id="front" href="/"><img src="/kayrx.png"/></a>
            <span id="dlnav">
              <a class="tail" id="nav-doc" href="/doc/" >文档</a>
              <a class="tail" id="nav-blog" href="/blog/2020/kayrxtishere.html" >博客</a>
            </span>
          </div>
          <label ><a href="#" id="menu">M</a></label>
        </div>
        <div id="rnav">
            <li ><a  id="nav-community" href="/community" >社区</a></li>
            <li > <a id="nav-funding" href="/funding">赞助</a></li>
        </div> 
    </div>

      <div id="content">
        <div class="container"><div class="doc-page doc-section-basic-server">
  <div class="doc-nav">
      
  <details id="pc" open>
      <summary id="dir"><strong>目录指南</strong></summary>

      <details open>
        <summary id="title"><strong>介绍</strong></summary>
        <a class="doc-section-link-intro-whatis" href="/doc/intro/whatis.html">何为kayrx</a>
        <a class="doc-section-link-intro-install" href="/doc/intro/install.html">安装</a>
      </details>
      
      <details open>
        <summary id="title"><strong>基本</strong></summary>
        <a class="doc-section-link-basic-start" href="/doc/basic/start.html">入门</a>
        <a class="doc-section-link-basic-app" href="/doc/basic/app.html">应用</a>
        <a class="doc-section-link-basic-server" href="/doc/basic/server.html">服务器</a>
        <a class="doc-section-link-basic-handler" href="/doc/basic/handler.html">处理器</a>
        <a class="doc-section-link-basic-extractor" href="/doc/basic/extractor.html">提取器</a>
      </details>
      
      <details open>
        <summary id="title"><strong>高级</strong></summary>
        <a class="doc-section-link-advance-request" href="/doc/advance/request.html">请求</a>
        <a class="doc-section-link-advance-url-dispatch" href="/doc/advance/url-dispatch.html">路由分发</a>
        <a class="doc-section-link-advance-response" href="/doc/advance/response.html">响应</a>
        <a class="doc-section-link-advance-middleware" href="/doc/advance/middleware.html">中间件</a>
        <a class="doc-section-link-advance-static-file" href="/doc/advance/static-file.html">静态文件</a>
        <a class="doc-section-link-advance-error" href="/doc/advance/error.html">错误</a>
        <a class="doc-section-link-advance-test" href="/doc/advance/test.html">测试</a>
      </details>
      
      <details open>
        <summary id="title"><strong>协议</strong></summary>
        <a class="doc-section-link-protocol-websocket" href="/doc/protocol/websocket.html">Websocket</a>
        <a class="doc-section-link-protocol-http2" href="/doc/protocol/http2.html">HTTP2</a>
      </details>
      
      <details open>
        <summary id="title"><strong>模式</strong></summary>
        <a class="doc-section-link-pattern-autoreload" href="/doc/pattern/autoreload.html">自动重载</a>
      </details>

      <details open>
        <summary id="title"><strong>数据库</strong></summary>
        <a class="doc-section-link-database-diesel" href="/doc/database/diesel.html">Diesel</a>
      </details>

      <details open>
        <summary id="title"><strong>深入kayrx</strong></summary>
        <a class="doc-section-link-deep-server" href="/doc/deep/server.html">Httpserver</a>
      </details>
      
  </details>

  <!-- ===============================Mobile==================================== -->

  <details id="mobile">
      <summary id="dir"><strong>目录指南</strong></summary>

      <details open>
        <summary id="title"><strong>介绍</strong></summary>
        <a class="doc-section-link-intro-whatis" href="/doc/intro/whatis.html">何为kayrx</a>
        <a class="doc-section-link-intro-install" href="/doc/intro/install.html">安装</a>
      </details>
      
      <details open>
        <summary id="title"><strong>基本</strong></summary>
        <a class="doc-section-link-basic-start" href="/doc/basic/start.html">入门</a>
        <a class="doc-section-link-basic-app" href="/doc/basic/app.html">应用</a>
        <a class="doc-section-link-basic-server" href="/doc/basic/server.html">服务器</a>
        <a class="doc-section-link-basic-handler" href="/doc/basic/handler.html">处理器</a>
        <a class="doc-section-link-basic-extractor" href="/doc/basic/extractor.html">提取器</a>
      </details>
      
      <details open>
        <summary id="title"><strong>高级</strong></summary>
        <a class="doc-section-link-advance-request" href="/doc/advance/request.html">请求</a>
        <a class="doc-section-link-advance-url-dispatch" href="/doc/advance/url-dispatch.html">路由分发</a>
        <a class="doc-section-link-advance-response" href="/doc/advance/response.html">响应</a>
        <a class="doc-section-link-advance-middleware" href="/doc/advance/middleware.html">中间件</a>
        <a class="doc-section-link-advance-static-file" href="/doc/advance/static-file.html">静态文件</a>
        <a class="doc-section-link-advance-error" href="/doc/advance/error.html">错误</a>
        <a class="doc-section-link-advance-test" href="/doc/advance/test.html">测试</a>
      </details>
      
      <details open>
        <summary id="title"><strong>协议</strong></summary>
        <a class="doc-section-link-protocol-websocket" href="/doc/protocol/websocket.html">Websocket</a>
        <a class="doc-section-link-protocol-http2" href="/doc/protocol/http2.html">HTTP2</a>
      </details>
      
      <details open>
        <summary id="title"><strong>模式</strong></summary>
        <a class="doc-section-link-pattern-autoreload" href="/doc/pattern/autoreload.html">自动重载</a>
      </details>

      <details open>
        <summary id="title"><strong>数据库</strong></summary>
        <a class="doc-section-link-database-diesel" href="/doc/database/diesel.html">Diesel</a>
      </details>

      <details open>
        <summary id="title"><strong>深入kayrx</strong></summary>
        <a class="doc-section-link-deep-server" href="/doc/deep/server.html">Httpserver</a>
      </details>
      
  </details>


  </div>
  <div class="doc-content"><h1 id="http%e6%9c%8d%e5%8a%a1%e5%99%a8">HTTP服务器</h1>
<p><a href="https://docs.rs/kayrx/0.7.5/kayrx/web/struct.HttpServer.html"><strong>HttpServer</strong></a>类型负责服务HTTP请求</p>
<p><code>HttpServer</code>接受应用工厂(app factory)作为参数，并且应用工厂必须具有<code>Send+ Sync</code>约束。有关更多信息，请参见<em>多线程</em>部分</p>
<p>要绑定到特定的套接字地址，必须使用<code>bind()</code>，并且可以多次调用它。要绑定<code>SSL</code>套接字，应该使用<a href="https://docs.rs/kayrx/0.7.5/kayrx/web/struct.HttpServer.html#method.bind_rustls">bind_rustls()</a>。要运行http服务器，请使用<code>HttpServer::run()</code> 方法</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> kayrx::web::{web, App, HttpResponse, HttpServer};

<span class="hljs-meta">#[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; std::io::<span class="hljs-built_in">Result</span>&lt;()&gt; {
    HttpServer::new(|| {
        App::new().route(<span class="hljs-string">"/"</span>, web::get().to(|| HttpResponse::<span class="hljs-literal">Ok</span>()))
    })
    .bind(<span class="hljs-string">"127.0.0.1:8088"</span>)?
    .run()
    .await
}
</div></code></pre>
<p><code>run()</code>方法返回<a href="https://docs.rs/kayrx/0.7.5/kayrx/web/dev/struct.Server.html">Server</a>类型的实例。Server类型的方法可用于管理http服务器</p>
<ul>
<li><code>pause()</code> -暂停接受传入的连接</li>
<li><code>resume()</code> -恢复接受传入的连接</li>
<li><code>stop()</code> -停止传入连接处理，停止所有工作程序并退出
以下示例显示如何在单独的线程中启动http服务器。</li>
</ul>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> kayrx::fiber::System;
<span class="hljs-keyword">use</span> kayrx::web::{web, App, HttpResponse, HttpServer};
<span class="hljs-keyword">use</span> std::sync::mpsc;
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-meta">#[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::channel();

    thread::spawn(<span class="hljs-keyword">move</span> || {
        <span class="hljs-keyword">let</span> sys = System::new(<span class="hljs-string">"http-server"</span>);

        <span class="hljs-keyword">let</span> srv = HttpServer::new(|| {
            App::new().route(<span class="hljs-string">"/"</span>, web::get().to(|| HttpResponse::<span class="hljs-literal">Ok</span>()))
        })
        .bind(<span class="hljs-string">"127.0.0.1:8088"</span>)?
        .shutdown_timeout(<span class="hljs-number">60</span>) <span class="hljs-comment">// &lt;- Set shutdown timeout to 60 seconds</span>
        .run();

        <span class="hljs-keyword">let</span> _ = tx.send(srv);
        sys.run()
    });

    <span class="hljs-keyword">let</span> srv = rx.recv().unwrap();

    <span class="hljs-comment">// pause accepting new connections</span>
    srv.pause().await;
    <span class="hljs-comment">// resume accepting new connections</span>
    srv.resume().await;
    <span class="hljs-comment">// stop server</span>
    srv.stop(<span class="hljs-literal">true</span>).await;
}
</div></code></pre>
<h2 id="%e5%a4%9a%e7%ba%bf%e7%a8%8b">多线程</h2>
<p><code>HttpServer</code>自动启动一些<code>http worker</code>，默认情况下，该数量等于系统中逻辑CPU的数量。该数字可以用该<a href="https://docs.rs/kayrx/0.7.5/kayrx/web/struct.HttpServer.html#method.workers">HttpServer::workers()</a>方法覆盖</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> kayrx::web::{web, App, HttpResponse, HttpServer};

<span class="hljs-meta">#[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    HttpServer::new(|| {
        App::new().route(<span class="hljs-string">"/"</span>, web::get().to(|| HttpResponse::<span class="hljs-literal">Ok</span>()))
    })
    .workers(<span class="hljs-number">4</span>); <span class="hljs-comment">// &lt;- Start 4 workers</span>
}
</div></code></pre>
<p>工作线程创建后，他们每个都会接受一个单独的应用实例来处理请求。线程之间不共享应用状态，并且处理程序可以自由地操作其状态副本，而无需担心并发问题。</p>
<p>应用状态不必为<code>Send或Sync</code>，但应用工厂必须为<code>Send+ Sync</code>。</p>
<p>要在工作线程之间共享状态，请使用<code>Arc</code>。引入共享和同步后，应格外小心。在许多情况下，由于锁定共享状态以进行修改而无意中引入了性能成本。</p>
<p>在某些情况下，可以使用更有效的锁定策略来减轻这些成本，例如，使用读/写锁而不是 互斥锁来实现非排他性锁定，但是性能最高的实现通常往往是根本不使用锁的实现。</p>
<p>由于每个工作线程都按顺序处理其请求，因此阻塞当前线程处理程序将导致当前工作线程停止处理新请求：</p>
<pre><code class="language-rust"><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">my_handler</span></span>() -&gt; <span class="hljs-keyword">impl</span> Responder {
    std::thread::sleep(Duration::from_secs(<span class="hljs-number">5</span>)); <span class="hljs-comment">// &lt;-- Bad practice! Will cause the current worker thread to hang!</span>
    <span class="hljs-string">"response"</span>
}
</div></code></pre>
<p>因此，任何长时间的，非cpu绑定的操作（例如，I / O，数据库操作等）都应表示为<code>Future</code>或异步函数。异步处理由工作线程并发执行，因此不会阻塞执行：</p>
<pre><code class="language-rust"><div>async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">my_handler</span></span>() -&gt; <span class="hljs-keyword">impl</span> Responder {
    kayrx::timer::delay_for(Duration::from_secs(<span class="hljs-number">5</span>)).await; <span class="hljs-comment">// &lt;-- Ok. Worker thread will handle other requests here</span>
    <span class="hljs-string">"response"</span>
}
</div></code></pre>
<p>同样的限制也适用于提取器。当处理函数收到实现<code>FromRequest</code>的参数，并且该实现阻塞当前线程时，工作线程将在运行处理程序时阻塞。为此，在实现提取器时必须特别注意，并且还应在需要时异步实现它们</p>
<h2 id="ssl">SSL</h2>
<p><code>SSL</code>服务器：<code>rustls</code> , 该 rustls 适用于 <code>rustls</code>集成</p>
<pre><code class="language-toml"><div><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">kayrx</span> = <span class="hljs-string">"0.7.5"</span>
<span class="hljs-attr">rustls</span> = <span class="hljs-string">"0.16"</span>
</div></code></pre>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> std::fs::File;
<span class="hljs-keyword">use</span> std::io::BufReader;
<span class="hljs-keyword">use</span> kayrx::web::{web, App, HttpRequest, HttpServer, Responder};
<span class="hljs-keyword">use</span> rustls::internal::pemfile::{certs, rsa_private_keys};
<span class="hljs-keyword">use</span> rustls::{NoClientAuth, ServerConfig};

async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(_req: HttpRequest) -&gt; <span class="hljs-keyword">impl</span> Responder {
    <span class="hljs-string">"Welcome!"</span>
}

<span class="hljs-meta">#[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; std::io::<span class="hljs-built_in">Result</span>&lt;()&gt; {
    <span class="hljs-comment">// load ssl keys</span>

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> config = ServerConfig::new(NoClientAuth::new());
    <span class="hljs-keyword">let</span> cert_file = &amp;<span class="hljs-keyword">mut</span> BufReader::new(File::open(<span class="hljs-string">"cert.pem"</span>).unwrap());
    <span class="hljs-keyword">let</span> key_file = &amp;<span class="hljs-keyword">mut</span> BufReader::new(File::open(<span class="hljs-string">"key.pem"</span>).unwrap());
    <span class="hljs-keyword">let</span> cert_chain = certs(cert_file).unwrap();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> keys = rsa_private_keys(key_file).unwrap();
    config.set_single_cert(cert_chain, keys.remove(<span class="hljs-number">0</span>)).unwrap();

    HttpServer::new(|| App::new().route(<span class="hljs-string">"/"</span>, web::get().to(index)))
        .bind_rustls(<span class="hljs-string">"127.0.0.1:8088"</span>, builder)?
        .run()
        .await
}
</div></code></pre>
<blockquote>
<p>For a full example, check out <a href="https://github.com/kayrx/awesome/tree/master/kayrx-examples/rustls">rustls</a>.</p>
</blockquote>
<h2 id="keep-alive">Keep-Alive</h2>
<p>kayrx::web 可以在保持活动连接上等待请求.</p>
<blockquote>
<p><em>keep alive</em> 保持活动连接行为由服务器设置定义.</p>
</blockquote>
<ul>
<li><code>75</code>, <code>Some(75)</code>, <code>KeepAlive::Timeout(75)</code> - enable 75 second <em>keep alive</em> timer.</li>
<li><code>None</code> or <code>KeepAlive::Disabled</code> - disable <em>keep alive</em>.</li>
<li><code>KeepAlive::Tcp(75)</code> - use <code>SO_KEEPALIVE</code> socket option.</li>
</ul>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> kayrx::web::{web, App, HttpResponse, HttpServer};

<span class="hljs-meta">#[kayrx::main]</span>
async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; std::io::<span class="hljs-built_in">Result</span>&lt;()&gt; {
    <span class="hljs-keyword">let</span> one = HttpServer::new(|| {
        App::new().route(<span class="hljs-string">"/"</span>, web::get().to(|| HttpResponse::<span class="hljs-literal">Ok</span>()))
    })
    .keep_alive(<span class="hljs-number">75</span>); <span class="hljs-comment">// &lt;- Set keep-alive to 75 seconds</span>

    <span class="hljs-comment">// let _two = HttpServer::new(|| {</span>
    <span class="hljs-comment">//     App::new().route("/", web::get().to(|| HttpResponse::Ok()))</span>
    <span class="hljs-comment">// })</span>
    <span class="hljs-comment">// .keep_alive(); // &lt;- Use `SO_KEEPALIVE` socket option.</span>

    <span class="hljs-keyword">let</span> _three = HttpServer::new(|| {
        App::new().route(<span class="hljs-string">"/"</span>, web::get().to(|| HttpResponse::<span class="hljs-literal">Ok</span>()))
    })
    .keep_alive(<span class="hljs-literal">None</span>); <span class="hljs-comment">// &lt;- Disable keep-alive</span>

    one.bind(<span class="hljs-string">"127.0.0.1:8088"</span>)?.run().await
}
</div></code></pre>
<p>如果选择了上面的第一个选项，则根据响应的<code>connection-type</code>计算<em>keep alive</em>状态。默认情况下未定义。在这种情况下，<em>keep alive</em>是由请求的 http版本定义的</p>
<blockquote>
<p><em>keep alive</em> is <strong>off</strong> for <em>HTTP/1.0</em> and is <strong>on</strong> for <em>HTTP/1.1</em> and <em>HTTP/2.0</em>.</p>
</blockquote>
<p>可以通过<code>HttpResponseBuilder::connection_type()</code>方法更改<em>Connection type</em>.</p>
<pre><code class="language-rust"><div><span class="hljs-keyword">use</span> kayrx::web::{http, HttpRequest, HttpResponse};

async <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">index</span></span>(req: HttpRequest) -&gt; HttpResponse {
    HttpResponse::<span class="hljs-literal">Ok</span>()
        .connection_type(http::ConnectionType::Close) <span class="hljs-comment">// &lt;- Close connection</span>
        .force_close() <span class="hljs-comment">// &lt;- Alternative method</span>
        .finish()
}
</div></code></pre>
<h2 id="%e4%bc%98%e9%9b%85%e5%85%b3%e6%9c%ba">优雅关机</h2>
<p><code>HttpServer</code>支持优雅关机。收到停止信号后，工作线程将有特定的时间来完成服务请求。超时后仍然存活的所有工人(工作线程)都被强制撤职。默认情况下，关闭超时设置为30秒。您可以使用<code>HttpServer::shutdown_timeout()</code> 方法更改此参数。</p>
<p>您可以使用服务器地址向服务器发送停止消息，并指定是否要正常关机。该<code>start()</code>方法返回服务器的地址。</p>
<p><code>HttpServer</code>处理几个操作系统信号。<code>CTRL-C</code>在所有操作系统上均可用，其他信号在<code>UNIX</code>系统上均可用。</p>
<ul>
<li>SIGINT-强制关机</li>
<li>SIGTERM-正常关闭的工人</li>
<li>SIGQUIT-强制关机工人</li>
</ul>
<p>可以使用<code>HttpServer::disable_signals()</code>方法禁用信号处理</p>




</div>
</div>

</div>
      </div>

      <div id="footer">
        &copy; 2019  <a href="https://github.com/kayrx/kayrx">Kayrx</a>
      </div>
    </div>
    <script async>
      window.onload = function() {
            let menu = document.getElementById('menu');
            menu.addEventListener('click', function() {
                let nav = document.getElementById('rnav');
                if (nav.style.height == 'auto') {
                        nav.style.height = '0';
                }else{
                        nav.style.height = 'auto';
                }
            }, false)
    }
</script>
  </body>
</html> 